1. Why?

Important warning: The default value is evaluated only once. This makes a difference when the default is a mutable object such as a list, dictionary, or instances of most classes. For example, the following function accumulates the arguments passed to it on subsequent calls:

def f(a, L=[]):
    L.append(a)
    return L

print(f(1))
print(f(2))
print(f(3))
This will print

[1]
[1, 2]
[1, 2, 3]

2. Finally, consider this function definition which has a potential collision between the positional argument name and **kwds which has name as a key:

def foo(name, **kwds):
    return 'name' in kwds
There is no possible call that will make it return True as the keyword 'name' will always to bind to the first parameter. For example:

>>>
>>> foo(1, **{'name': 2})
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: foo() got multiple values for argument 'name'
>>>
But using / (positional only arguments), it is possible since it allows name as a positional argument and 'name' as a key in the keyword arguments:

def foo(name, /, **kwds):
    return 'name' in kwds
>>> foo(1, **{'name': 2})
True
In other words, the names of positional-only parameters can be used in **kwds without ambiguity.

Question: Why can't we use '*' instead '/'.

3. >>> def concat(separator='/',*args,**kwag):
...     a = separator.join(args)
...     a = a + separator.join(kwag.values())
...     print(a)
... 
>>> concat('*',*lis,*dic)
pratik*a*b*x*y

Question: Why x and y instead of 1 and 2.